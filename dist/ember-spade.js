minispade.register('list-view/list_item_view', "(function() {minispade.require('list-view/list_item_view_mixin');\n\nvar get = Ember.get, set = Ember.set;\n\nvar backportedInnerString = function(buffer) {\n  var content = [], childBuffers = buffer.childBuffers;\n\n  Ember.ArrayPolyfills.forEach.call(childBuffers, function(buffer) {\n    var stringy = typeof buffer === 'string';\n    if (stringy) {\n      content.push(buffer);\n    } else {\n      buffer.array(content);\n    }\n  });\n\n  return content.join('');\n};\n\nfunction willInsertElementIfNeeded(view) {\n  if (view.willInsertElement) {\n    view.willInsertElement();\n  }\n}\n\nfunction didInsertElementIfNeeded(view) {\n  if (view.didInsertElement) {\n    view.didInsertElement();\n  }\n}\n\nfunction rerender() {\n  var element, buffer, context, hasChildViews;\n  element = get(this, 'element');\n\n  if (!element) { return; }\n\n  context = get(this, 'context');\n\n  // releases action helpers in contents\n  // this means though that the ListViewItem itself can't use classBindings or attributeBindings\n  // need support for rerender contents in ember\n  this.triggerRecursively('willClearRender');\n\n  if (this.lengthAfterRender > this.lengthBeforeRender) {\n    this.clearRenderedChildren();\n    this._childViews.length = this.lengthBeforeRender; // triage bug in ember\n  }\n\n  if (context) {\n    buffer = Ember.RenderBuffer();\n    buffer = this.renderToBuffer(buffer);\n\n    // check again for childViews, since rendering may have added some\n    hasChildViews = this._childViews.length > 0;\n\n    if (hasChildViews) {\n      this.invokeRecursively(willInsertElementIfNeeded, false);\n    }\n\n    element.innerHTML = buffer.innerString ? buffer.innerString() : backportedInnerString(buffer);\n\n    set(this, 'element', element);\n\n    this.transitionTo('inDOM');\n\n    if (hasChildViews) {\n      this.invokeRecursively(didInsertElementIfNeeded, false);\n    }\n  } else {\n    element.innerHTML = ''; // when there is no context, this view should be completely empty\n  }\n}\n\n/**\n  The `Ember.ListViewItem` view class renders a\n  [div](https://developer.mozilla.org/en/HTML/Element/div) HTML element\n  with `ember-list-item-view` class. It allows you to specify a custom item\n  handlebars template for `Ember.ListView`.\n\n  Example:\n\n  ```handlebars\n  <script type=\"text/x-handlebars\" data-template-name=\"row_item\">\n    {{name}}\n  </script>\n  ```\n\n  ```javascript\n  App.ListView = Ember.ListView.extend({\n    height: 500,\n    rowHeight: 20,\n    itemViewClass: Ember.ListItemView.extend({templateName: \"row_item\"})\n  });\n  ```\n\n  @extends Ember.View\n  @class ListItemView\n  @namespace Ember\n*/\nEmber.ListItemView = Ember.View.extend(Ember.ListItemViewMixin, {\n  updateContext: function(newContext){\n    var context = get(this, 'context');\n    Ember.instrument('view.updateContext.render', this, function() {\n      if (context !== newContext) {\n        this.set('context', newContext);\n        if (newContext instanceof Ember.ObjectController) {\n          this.set('controller', newContext);\n        }\n      }\n    }, this);\n  },\n  rerender: function () { Ember.run.scheduleOnce('render', this, rerender); },\n  _contextDidChange: Ember.observer(rerender, 'context', 'controller')\n});\n\n})();\n//@ sourceURL=list-view/list_item_view");minispade.register('list-view/list_item_view_mixin', "(function() {var get = Ember.get, set = Ember.set;\n\nfunction samePosition(a, b) {\n  return a && b && a.x === b.x && a.y === b.y;\n}\n\nfunction positionElement() {\n  var element, position, _position;\n\n  Ember.instrument('view.updateContext.positionElement', this, function() {\n    element = get(this, 'element');\n    position = get(this, 'position');\n    _position = this._position;\n\n    if (!position || !element) { return; }\n\n    // TODO: avoid needing this by avoiding unnecessary\n    // calls to this method in the first place\n    if (samePosition(position, _position)) { return; }\n    this._parentView.applyTransform(element, position.x, position.y);\n\n    this._position = position;\n  }, this);\n}\n\nEmber.ListItemViewMixin = Ember.Mixin.create({\n  init: function(){\n    this._super();\n    this.one('didInsertElement', positionElement);\n  },\n  classNames: ['ember-list-item-view'],\n  _position: null,\n  _positionDidChange: Ember.observer(positionElement, 'position'),\n  _positionElement: positionElement\n});\n\n})();\n//@ sourceURL=list-view/list_item_view_mixin");minispade.register('list-view/list_view', "(function() {minispade.require('list-view/list_view_mixin');\nminispade.require('list-view/list_view_helper');\n\nvar get = Ember.get, set = Ember.set;\n\n/**\n  The `Ember.ListView` view class renders a\n  [div](https://developer.mozilla.org/en/HTML/Element/div) HTML element,\n  with `ember-list-view` class.\n\n  The context of each item element within the `Ember.ListView` are populated\n  from the objects in the `Element.ListView`'s `content` property.\n\n  ### `content` as an Array of Objects\n\n  The simplest version of an `Ember.ListView` takes an array of object as its\n  `content` property. The object will be used as the `context` each item element\n  inside the rendered `div`.\n\n  Example:\n\n  ```javascript\n  App.contributors = [{ name: 'Stefan Penner' }, { name: 'Alex Navasardyan' }, { name: 'Rey Cohen'}];\n  ```\n\n  ```handlebars\n  {{#collection Ember.ListView contentBinding=\"App.contributors\" height=500 rowHeight=50}}\n    {{name}}\n  {{/collection}}\n  ```\n\n  Would result in the following HTML:\n\n  ```html\n   <div id=\"ember181\" class=\"ember-view ember-list-view\" style=\"height:500px;width:500px;position:relative;overflow:scroll;-webkit-overflow-scrolling:touch;overflow-scrolling:touch;\">\n    <div class=\"ember-list-container\">\n      <div id=\"ember186\" class=\"ember-view ember-list-item-view\" style=\"-webkit-transform: translate3d(0px, 0px, 0);\">\n        <script id=\"metamorph-0-start\" type=\"text/x-placeholder\"></script>Stefan Penner<script id=\"metamorph-0-end\" type=\"text/x-placeholder\"></script>\n      </div>\n      <div id=\"ember187\" class=\"ember-view ember-list-item-view\" style=\"-webkit-transform: translate3d(0px, 50px, 0);\">\n        <script id=\"metamorph-1-start\" type=\"text/x-placeholder\"></script>Alex Navasardyan<script id=\"metamorph-1-end\" type=\"text/x-placeholder\"></script>\n      </div>\n      <div id=\"ember188\" class=\"ember-view ember-list-item-view\" style=\"-webkit-transform: translate3d(0px, 100px, 0);\">\n        <script id=\"metamorph-2-start\" type=\"text/x-placeholder\"></script>Rey Cohen<script id=\"metamorph-2-end\" type=\"text/x-placeholder\"></script>\n      </div>\n      <div id=\"ember189\" class=\"ember-view ember-list-scrolling-view\" style=\"height: 150px\"></div>\n    </div>\n  </div>\n  ```\n\n  By default `Ember.ListView` provides support for `height`,\n  `rowHeight`, `width`, `elementWidth`, `scrollOffset` parameters.\n\n  Note, that `height` and `rowHeight` are required parameters.\n\n  ```handlebars\n  {{#collection Ember.ListView contentBinding=\"App.contributors\" height=500 rowHeight=50}}\n    {{name}}\n  {{/collection}}\n  ```\n\n  If you would like to have multiple columns in your view layout, you can\n  set `width` and `elementWidth` parameters respectively.\n\n  ```handlebars\n  {{#collection Ember.ListView contentBinding=\"App.contributors\" height=500 rowHeight=50 width=500 elementWidth=80}}\n    {{name}}\n  {{/collection}}\n  ```\n\n  ### extending `Ember.ListView`\n\n  Example:\n\n  ```handlebars\n  {{view App.ListView contentBinding=\"content\"}}\n\n  <script type=\"text/x-handlebars\" data-template-name=\"row_item\">\n    {{name}}\n  </script>\n  ```\n\n  ```javascript\n  App.ListView = Ember.ListView.extend({\n    height: 500,\n    width: 500,\n    elementWidth: 80,\n    rowHeight: 20,\n    itemViewClass: Ember.ListItemView.extend({templateName: \"row_item\"})\n  });\n  ```\n\n  @extends Ember.ContainerView\n  @class ListView\n  @namespace Ember\n*/\nEmber.ListView = Ember.ContainerView.extend(Ember.ListViewMixin, {\n  css: {\n    position: 'relative',\n    overflow: 'scroll',\n    '-webkit-overflow-scrolling': 'touch',\n    'overflow-scrolling': 'touch'\n  },\n\n  applyTransform: Ember.ListViewHelper.applyTransform,\n\n  _scrollTo: function(scrollOffset) {\n    var element = get(this, 'element');\n\n    if (element) { element[get(this, 'isHorizontal') ? 'scrollLeft' : 'scrollTop'] = scrollOffset; }\n  },\n\n  didInsertElement: function() {\n    var that, element;\n\n    that = this;\n    element = get(this, 'element');\n\n    this._updateScrollableSize();\n\n    this._scroll = function(e) { that.scroll(e); };\n\n    Ember.$(element).on('scroll', this._scroll);\n  },\n\n  willDestroyElement: function() {\n    var element;\n\n    element = get(this, 'element');\n\n    Ember.$(element).off('scroll', this._scroll);\n  },\n\n  scroll: function(e) {\n    Ember.run(this, this.scrollTo, e.target[get(this, 'isHorizontal') ? 'scrollLeft' : 'scrollTop']);\n  },\n\n  scrollTo: function(offset){\n    this._scrollTo(offset);\n    this._scrollContentTo(offset);\n  },\n\n  totalSizeDidChange: Ember.observer(function () {\n    Ember.run.scheduleOnce('afterRender', this, this._updateScrollableSize);\n  }, 'totalSize'),\n\n  _updateScrollableSize: function () {\n    var height = '', width = '';\n    if (this.state === 'inDOM') {\n      if ( get(this, 'isHorizontal') ) {\n        width = get(this, 'totalSize');\n      } else {\n        height = get(this, 'totalSize');\n      }\n      this.$('.ember-list-container').css({\n        height: height,\n        width: width\n      });\n    }\n  }\n});\n\n})();\n//@ sourceURL=list-view/list_view");minispade.register('list-view/list_view_helper', "(function() {var el = document.createElement('div'), style = el.style;\n\nvar propPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\n\nfunction testProp(prop) {\n  if (prop in style) return prop;\n  var uppercaseProp = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i=0; i<propPrefixes.length; i++) {\n    var prefixedProp = propPrefixes[i] + uppercaseProp;\n    if (prefixedProp in style) {\n      return prefixedProp;\n    }\n  }\n  return null;\n}\n\nvar transformProp = testProp('transform');\nvar perspectiveProp = testProp('perspective');\n\nvar supports2D = transformProp !== null;\nvar supports3D = perspectiveProp !== null;\n\nEmber.ListViewHelper = {\n  transformProp: transformProp,\n  applyTransform: (function(){\n    if (supports2D) {\n      return function(element, x, y){\n        element.style[transformProp] = 'translate(' + x + 'px, ' + y + 'px)';\n      };\n    } else {\n      return function(element, x, y){\n        element.style.top  = y + 'px';\n        element.style.left = x + 'px';\n      };\n    }\n  })(),\n  apply3DTransform: (function(){\n    if (supports3D) {\n      return function(element, x, y){\n        element.style[transformProp] = 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n      };\n    } else if (supports2D) {\n      return function(element, x, y){\n        element.style[transformProp] = 'translate(' + x + 'px, ' + y + 'px)';\n      };\n    } else {\n      return function(element, x, y){\n        element.style.top  = y + 'px';\n        element.style.left = x + 'px';\n      };\n    }\n  })()\n};\n\n})();\n//@ sourceURL=list-view/list_view_helper");minispade.register('list-view/list_view_mixin', "(function() {minispade.require('list-view/list_view_helper');\n\nvar get = Ember.get, set = Ember.set,\nmin = Math.min, max = Math.max, floor = Math.floor,\nceil = Math.ceil,\nforEach = Ember.ArrayPolyfills.forEach;\n\nfunction addContentArrayObserver() {\n  var content = get(this, 'content');\n  if (content) {\n    content.addArrayObserver(this);\n  }\n}\n\nfunction removeAndDestroy(object){\n  this.removeObject(object);\n  object.destroy();\n}\n\nfunction syncChildViews(){\n  Ember.run.once(this, '_syncChildViews');\n}\n\nfunction sortByContentIndex (viewOne, viewTwo){\n  return get(viewOne, 'contentIndex') - get(viewTwo, 'contentIndex');\n}\n\nfunction notifyMutationListeners() {\n  if (Ember.View.notifyMutationListeners) {\n    Ember.run.once(Ember.View, 'notifyMutationListeners');\n  }\n}\n\nvar domManager = Ember.create(Ember.ContainerView.proto().domManager);\n\ndomManager.prepend = function(view, html) {\n  view.$('.ember-list-container').prepend(html);\n  notifyMutationListeners();\n};\n\nfunction syncListContainerSize(){\n  var elementWidth, columnCount, containerWidth, element,\n      elementHeight, rowCount, containerHeight;\n  if ( get(this, 'isHorizontal') ) {\n    // horizontal list\n    elementHeight = get(this, 'elementHeight');\n    rowCount = get(this, 'rowCount');\n    containerHeight = elementHeight * rowCount;\n    element = this.$('.ember-list-container');\n    if (containerHeight && element) {\n      element.css('height', containerHeight);\n    }\n  } else {\n    // vertical list\n    elementWidth = get(this, 'elementWidth');\n    columnCount = get(this, 'columnCount');\n    containerWidth = elementWidth * columnCount;\n    element = this.$('.ember-list-container');\n    if (containerWidth && element) {\n      element.css('width', containerWidth);\n    }\n  }\n}\n\nfunction enableProfilingOutput() {\n  function before(name, time, payload) {\n    console.time(name);\n  }\n\n  function after (name, time, payload) {\n    console.timeEnd(name);\n  }\n\n  if (Ember.ENABLE_PROFILING) {\n    Ember.subscribe('view._scrollContentTo', {\n      before: before,\n      after: after\n    });\n    Ember.subscribe('view.updateContext', {\n      before: before,\n      after: after\n    });\n  }\n}\n\n/**\n  @class Ember.ListViewMixin\n  @namespace Ember\n*/\nEmber.ListViewMixin = Ember.Mixin.create({\n  itemViewClass: Ember.ListItemView,\n  emptyViewClass: Ember.View,\n  classNames: ['ember-list-view'],\n  attributeBindings: ['style'],\n  domManager: domManager,\n  scrollOffset: 0,\n  bottomPadding: 0,\n  rightPadding: 0,\n  _lastEndingIndex: 0,\n  paddingCount: 1,\n  isHorizontal: false,\n\n  totalSize: Ember.computed('isHorizontal', 'totalWidth', 'totalHeight', function() {\n    if ( get(this, 'isHorizontal') ) {\n      return get(this, 'totalWidth');\n    }\n    return get(this, 'totalHeight');\n  }),\n\n  size: Ember.computed('isHorizontal', 'width', 'height', function() {\n    if ( get(this, 'isHorizontal') ) {\n      return get(this, 'width');\n    }\n    return get(this, 'height');\n  }),\n\n\n  /**\n    @private\n\n    Setup a mixin.\n    - adding observer to content array\n    - creating child views based on height and length of the content array\n\n    @method init\n  */\n  init: function() {\n    this._super();\n    this.on('didInsertElement', syncListContainerSize);\n    this.columnCountDidChange();\n    this.rowCountDidChange();\n    this._syncChildViews();\n    this._addContentArrayObserver();\n  },\n\n  _addContentArrayObserver: Ember.beforeObserver(function() {\n    addContentArrayObserver.call(this);\n  }, 'content'),\n\n  /**\n    Called on your view when it should push strings of HTML into a\n    `Ember.RenderBuffer`.\n\n    Adds a [div](https://developer.mozilla.org/en-US/docs/HTML/Element/div)\n    with a required `ember-list-container` class.\n\n    @method render\n    @param {Ember.RenderBuffer} buffer The render buffer\n  */\n  render: function(buffer) {\n    buffer.push('<div class=\"ember-list-container\">');\n    this._super(buffer);\n    buffer.push('</div>');\n  },\n\n  willInsertElement: function() {\n    if ( this.get('isHorizontal') ) {\n      if (!this.get(\"width\") || !this.get(\"columnWidth\")) {\n        throw new Error(\"An horizontal ListView must be created with a width and a columnWidth.\");\n      }\n    } else {\n      if (!this.get(\"height\") || !this.get(\"rowHeight\")) {\n        throw new Error(\"A vertical ListView must be created with a height and a rowHeight.\");\n      }\n    }\n    this._super();\n  },\n\n  /**\n    @private\n\n    Sets inline styles of the view:\n    - height\n    - width\n    - position\n    - overflow\n    - -webkit-overflow\n    - overflow-scrolling\n\n    Called while attributes binding.\n\n    @property {Ember.ComputedProperty} style\n  */\n  style: Ember.computed('height', 'width', function() {\n    var height, width, style, css;\n\n    height = get(this, 'height');\n    width = get(this, 'width');\n    css = get(this, 'css');\n\n    style = '';\n\n    if (height) { style += 'height:' + height + 'px;'; }\n    if (width)  { style += 'width:'  + width  + 'px;'; }\n\n    for ( var rule in css ){\n      if (css.hasOwnProperty(rule)) {\n        style += rule + ':' + css[rule] + ';';\n      }\n    }\n\n    return style;\n  }),\n\n  /**\n    @private\n\n    Performs visual scrolling. Is overridden in Ember.ListView.\n\n    @method scrollTo\n  */\n  scrollTo: function(offset) {\n    throw new Error('must override to perform the visual scroll and effectively delegate to _scrollContentTo');\n  },\n\n  /**\n    @private\n\n    Internal method used to force scroll position\n\n    @method scrollTo\n  */\n  _scrollTo: Ember.K,\n\n  /**\n    @private\n    @method _scrollContentTo\n  */\n  _scrollContentTo: function(offset) {\n    var startingIndex, endingIndex,\n        visibleEndingIndex, maxContentIndex,\n        contentLength, scrollOffset;\n\n    scrollOffset = max(0, offset);\n\n    if (get(this, 'scrollOffset') === scrollOffset) {\n      return;\n    }\n\n    // allow a visual overscroll, but don't scroll the content. As we are doing needless\n    // recycyling, and adding unexpected nodes to the DOM.\n    scrollOffset = Math.min(scrollOffset, (get(this, 'totalSize') - get(this, 'size')));\n\n    Ember.instrument('view._scrollContentTo', {\n      scrollOffset: scrollOffset,\n      content: get(this, 'content'),\n      startingIndex: this._startingIndex(),\n      endingIndex: min(max(get(this, 'content.length') - 1, 0), this._startingIndex() + this._numChildViewsForViewport())\n    }, function () {\n      contentLength = get(this, 'content.length');\n      set(this, 'scrollOffset', scrollOffset);\n\n      maxContentIndex = max(contentLength - 1, 0);\n\n      startingIndex = this._startingIndex();\n      visibleEndingIndex = startingIndex + this._numChildViewsForViewport();\n\n      endingIndex = min(maxContentIndex, visibleEndingIndex);\n\n      this.trigger('scrollOffsetChanged', offset);\n\n      if (startingIndex === this._lastStartingIndex &&\n          endingIndex === this._lastEndingIndex) {\n        return;\n      }\n\n      this._reuseChildren();\n\n      this._lastStartingIndex = startingIndex;\n      this._lastEndingIndex = endingIndex;\n    }, this);\n  },\n\n  /**\n    @private\n\n    Computes the height for a `Ember.ListView` scrollable container div.\n    You must specify `rowHeight` parameter for the height to be computed properly.\n\n    @property {Ember.ComputedProperty} totalHeight\n  */\n  totalHeight: Ember.computed('content.length', 'rowHeight', 'columnCount', 'bottomPadding', 'isHorizontal', function() {\n    var contentLength, rowHeight, columnCount, bottomPadding;\n    if ( get(this, 'isHorizontal') ) return get(this, 'height');\n    contentLength = get(this, 'content.length');\n    rowHeight = get(this, 'rowHeight');\n    columnCount = get(this, 'columnCount');\n    bottomPadding = get(this, 'bottomPadding');\n\n    return ((ceil(contentLength / columnCount)) * rowHeight) + bottomPadding;\n  }),\n\n  /**\n    @private\n\n    Computes the width for a `Ember.ListView` scrollable container div.\n    You must specify `columnWidth` parameter for the width to be computed properly.\n\n    @property {Ember.ComputedProperty} totalWidth\n  */\n  totalWidth: Ember.computed('content.length', 'columnWidth', 'rowCount', 'rightPadding', 'isHorizontal', function() {\n    var contentLength, columnWidth, rowCount, rightPadding;\n    if ( !get(this, 'isHorizontal') ) return get(this, 'width');\n    contentLength = get(this, 'content.length');\n    columnWidth = get(this, 'columnWidth');\n    rowCount = get(this, 'rowCount');\n    rightPadding = get(this, 'rightPadding');\n\n    return ((ceil(contentLength / rowCount)) * columnWidth) + rightPadding;\n  }),\n\n  /**\n    @private\n    @method _prepareChildForReuse\n  */\n  _prepareChildForReuse: function(childView) {\n    childView.prepareForReuse();\n  },\n\n  /**\n    @private\n    @method _reuseChildForContentIndex\n  */\n  _reuseChildForContentIndex: function(childView, contentIndex) {\n    var content, newContext, position, enableProfiling;\n\n    content = get(this, 'content');\n    enableProfiling = get(this, 'enableProfiling');\n    position = this.positionForIndex(contentIndex);\n    set(childView, 'position', position);\n\n    set(childView, 'contentIndex', contentIndex);\n\n    if (enableProfiling) {\n      Ember.instrument('view._reuseChildForContentIndex', position, function(){}, this);\n    }\n\n    newContext = content.objectAt(contentIndex);\n    childView.updateContext(newContext);\n  },\n\n  /**\n    @private\n    @method positionForIndex\n  */\n  positionForIndex: function(index){\n    var elementWidth, columnCount, rowHeight, y, x,\n        elementHeight, rowCount, columnWidth;\n\n    if ( get(this, 'isHorizontal') ) {\n      // list is horizontal\n      elementHeight = get(this, 'elementHeight') || 1;\n      rowCount = get(this, 'rowCount');\n      columnWidth = get(this, 'columnWidth');\n\n      x = (columnWidth * floor(index/rowCount));\n      y = (index % rowCount) * elementHeight;\n\n      return {\n        y: y,\n        x: x\n      };\n    } else {\n      // list is vertical\n      elementWidth = get(this, 'elementWidth') || 1;\n      columnCount = get(this, 'columnCount');\n      rowHeight = get(this, 'rowHeight');\n\n      y = (rowHeight * floor(index/columnCount));\n      x = (index % columnCount) * elementWidth;\n\n      return {\n        y: y,\n        x: x\n      };\n    }\n  },\n\n  /**\n    @private\n    @method _childViewCount\n  */\n  _childViewCount: function() {\n    var contentLength, childViewCountForSize;\n\n    contentLength = get(this, 'content.length');\n    childViewCountForSize = this._numChildViewsForViewport();\n\n    return min(contentLength, childViewCountForSize);\n  },\n\n  /**\n    @private\n\n    Returns a number of columns in the Ember.ListView (for grid layout).\n\n    If you want to have a multi column layout, you need to specify both\n    `width` and `elementWidth`.\n\n    If no `elementWidth` is specified, it returns `1`. Otherwise, it will\n    try to fit as many columns as possible for a given `width`.\n\n    @property {Ember.ComputedProperty} columnCount\n  */\n  columnCount: Ember.computed('width', 'elementWidth', function() {\n    var elementWidth, width, count;\n\n    elementWidth = get(this, 'elementWidth');\n    width = get(this, 'width');\n\n    if (elementWidth) {\n      count = floor(width / elementWidth);\n    } else {\n      count = 1;\n    }\n\n    return count;\n  }),\n\n  /**\n    @private\n\n    Fires every time column count is changed.\n\n    @event columnCountDidChange\n  */\n  columnCountDidChange: Ember.observer(function(){\n    var ratio, currentScrollOffset, proposedScrollOffset, maxScrollOffset,\n        scrollOffset, lastColumnCount, newColumnCount;\n\n    if ( get(this, 'isHorizontal') ) return;\n\n    lastColumnCount = this._lastColumnCount;\n\n    currentScrollOffset = get(this, 'scrollOffset');\n    newColumnCount = get(this, 'columnCount');\n    maxScrollOffset = get(this, 'maxScrollTop');\n\n    this._lastColumnCount = newColumnCount;\n\n    if (lastColumnCount) {\n      ratio = (lastColumnCount / newColumnCount);\n      proposedScrollOffset = currentScrollOffset * ratio;\n      scrollOffset = min(maxScrollOffset, proposedScrollOffset);\n\n      this._scrollTo(scrollOffset);\n      set(this, 'scrollOffset', scrollOffset);\n    }\n\n    if (arguments.length > 0) {\n      // invoked by observer\n      Ember.run.schedule('afterRender', this, syncListContainerSize);\n    }\n  }, 'columnCount'),\n\n  /**\n    @private\n\n    Computes max possible scrollTop value given the visible viewport\n    and scrollable container div height.\n\n    @property {Ember.ComputedProperty} maxScrollTop\n  */\n  maxScrollTop: Ember.computed('height', 'totalHeight', function(){\n    var totalHeight, viewportHeight;\n\n    totalHeight = get(this, 'totalHeight');\n    viewportHeight = get(this, 'height');\n\n    return max(0, totalHeight - viewportHeight);\n  }),\n\n  /**\n    @private\n\n    Returns a number of rows in the Ember.ListView (for grid layout and horizontal list view).\n\n    If you want to have a multi row layout in horizontal list, you need to specify both\n    `height` and `elementHeight`.\n\n    If no `elementHeight` is specified, it returns `1`. Otherwise, it will\n    try to fit as many columns as possible for a given `height`.\n\n    @property {Ember.ComputedProperty} rowCount\n  */\n  rowCount: Ember.computed('height', 'elementHeight', function() {\n    var elementHeight, height, count;\n\n    elementHeight = get(this, 'elementHeight');\n    height = get(this, 'height');\n\n    if (elementHeight) {\n      count = floor(height / elementHeight);\n    } else {\n      count = 1;\n    }\n\n    return count;\n  }),\n\n  /**\n    @private\n\n    Fires every time row count is changed.\n\n    @event rowCountDidChange\n  */\n  rowCountDidChange: Ember.observer(function(){\n    var ratio, currentScrollOffset, proposedScrollOffset, maxScrollOffset,\n        scrollOffset, lastRowCount, newRowCount;\n\n    if ( !get(this, 'isHorizontal') ) return;\n\n    lastRowCount = this._lastRowCount;\n\n    currentScrollOffset = get(this, 'scrollOffset');\n    newRowCount = get(this, 'rowCount');\n    maxScrollOffset = get(this, 'maxScrollLeft');\n\n    this._lastRowCount = newRowCount;\n\n    if (lastRowCount) {\n      ratio = (lastRowCount / newRowCount);\n      proposedScrollOffset = currentScrollOffset * ratio;\n      scrollOffset = min(maxScrollOffset, proposedScrollOffset);\n\n      this._scrollTo(scrollOffset);\n      set(this, 'scrollOffset', scrollOffset);\n    }\n\n    if (arguments.length > 0) {\n      // invoked by observer\n      Ember.run.schedule('afterRender', this, syncListContainerSize);\n    }\n  }, 'rowCount'),\n\n  /**\n    @private\n\n    Computes max possible scrollLeft value given the visible viewport\n    and scrollable container div width.\n\n    @property {Ember.ComputedProperty} maxScrollLeft\n  */\n  maxScrollLeft: Ember.computed('width', 'totalWidth', function(){\n    var totalWidth, viewportWidth;\n\n    totalWidth = get(this, 'totalWidth');\n    viewportWidth = get(this, 'width');\n\n    return max(0, totalWidth - viewportWidth);\n  }),\n\n  /**\n    @private\n\n    Computes the number of views that would fit in the viewport area.\n    You must specify `height` and `rowHeight` parameters for the number of\n    views to be computed properly (or `width` and `columnWidth` in case of horizontal list)\n\n    @method _numChildViewsForViewport\n  */\n  _numChildViewsForViewport: function() {\n    var height, rowHeight, paddingCount, columnCount,\n        width, columnWidth, rowCount;\n    if ( get(this, 'isHorizontal') ) {\n      // horizontal mode\n      width = get(this, 'width');\n      columnWidth = get(this, 'columnWidth');\n      paddingCount = get(this, 'paddingCount');\n      rowCount = get(this, 'rowCount');\n      return (ceil(width / columnWidth) * rowCount) + (paddingCount * rowCount);\n    } else {\n      // vertical mode\n      height = get(this, 'height');\n      rowHeight = get(this, 'rowHeight');\n      paddingCount = get(this, 'paddingCount');\n      columnCount = get(this, 'columnCount');\n      return (ceil(height / rowHeight) * columnCount) + (paddingCount * columnCount);\n    }\n  },\n\n  /**\n    @private\n\n    Computes the starting index of the item views array.\n    Takes `scrollOffset` property of the element into account.\n\n    Is used in `_syncChildViews`.\n\n    @method _startingIndex\n  */\n  _startingIndex: function() {\n    var scrollOffset, rowHeight, columnCount, calculatedStartingIndex,\n        contentLength, largestStartingIndex, columnWidth, rowCount;\n    contentLength = get(this, 'content.length');\n    scrollOffset = get(this, 'scrollOffset');\n    if ( get(this, 'isHorizontal') ) {\n      // horizontal list\n      columnWidth = get(this, 'columnWidth');\n      rowCount = get(this, 'rowCount');\n      calculatedStartingIndex = floor(scrollOffset / columnWidth) * rowCount;\n      largestStartingIndex = max(contentLength - 1, 0);\n      return min(calculatedStartingIndex, largestStartingIndex);\n    } else {\n      // vertical list\n      rowHeight = get(this, 'rowHeight');\n      columnCount = get(this, 'columnCount');\n      calculatedStartingIndex = floor(scrollOffset / rowHeight) * columnCount;\n      largestStartingIndex = max(contentLength - 1, 0);\n      return min(calculatedStartingIndex, largestStartingIndex);\n    }\n  },\n\n  /**\n    @private\n    @event contentWillChange\n  */\n  contentWillChange: Ember.beforeObserver(function() {\n    var content;\n\n    content = get(this, 'content');\n\n    if (content) {\n      content.removeArrayObserver(this);\n    }\n  }, 'content'),\n\n  /**),\n    @private\n    @event contentDidChange\n  */\n  contentDidChange: Ember.observer(function() {\n    addContentArrayObserver.call(this);\n    syncChildViews.call(this);\n  }, 'content'),\n\n  /**\n    @private\n    @property {Function} needsSyncChildViews\n  */\n  needsSyncChildViews: Ember.observer(syncChildViews, 'height', 'width', 'columnCount', 'rowCount', 'isHorizontal'),\n\n  /**\n    @private\n\n    Returns a new item view. Takes `contentIndex` to set the context\n    of the returned view properly.\n\n    @param {Number} contentIndex item index in the content array\n    @method _addItemView\n  */\n  _addItemView: function(contentIndex){\n    var itemViewClass, childView;\n\n    itemViewClass = get(this, 'itemViewClass');\n    childView = this.createChildView(itemViewClass);\n\n    this.pushObject(childView);\n   },\n\n  /**\n    @private\n\n    Intelligently manages the number of childviews.\n\n    @method _syncChildViews\n   **/\n  _syncChildViews: function(){\n    var startingIndex, childViewCount,\n        numberOfChildViews, numberOfChildViewsNeeded,\n        childViews, count, delta, contentIndex;\n\n    if (get(this, 'isDestroyed') || get(this, 'isDestroying')) {\n      return;\n    }\n\n    childViewCount = this._childViewCount();\n    childViews = this.positionOrderedChildViews();\n\n    startingIndex = this._startingIndex();\n\n    numberOfChildViewsNeeded = childViewCount;\n    numberOfChildViews = childViews.length;\n\n    delta = numberOfChildViewsNeeded - numberOfChildViews;\n\n    if (delta === 0) {\n      // no change\n    } else if (delta > 0) {\n      // more views are needed\n      contentIndex = this._lastEndingIndex;\n\n      for (count = 0; count < delta; count++, contentIndex++) {\n        this._addItemView(contentIndex);\n      }\n\n    } else {\n      // less views are needed\n      forEach.call(\n        childViews.splice(numberOfChildViewsNeeded, numberOfChildViews),\n        removeAndDestroy,\n        this\n      );\n    }\n\n    this._reuseChildren();\n\n    this._lastStartingIndex = startingIndex;\n    this._lastEndingIndex   = this._lastEndingIndex + delta;\n  },\n\n  /**\n    @private\n    @method _reuseChildren\n  */\n  _reuseChildren: function(){\n    var childViews, childViewsLength,\n        startingIndex, childView,\n        contentIndex, visibleEndingIndex,\n        contentIndexEnd;\n\n    childViews = this.getReusableChildViews();\n    childViewsLength =  childViews.length;\n\n    startingIndex = this._startingIndex();\n    visibleEndingIndex = startingIndex + this._numChildViewsForViewport();\n\n    contentIndexEnd = min(visibleEndingIndex, startingIndex + childViewsLength);\n\n    for (contentIndex = startingIndex; contentIndex < contentIndexEnd; contentIndex++) {\n      childView = childViews[contentIndex % childViewsLength];\n      this._reuseChildForContentIndex(childView, contentIndex);\n    }\n  },\n\n  /**\n    @private\n    @method getReusableChildViews\n  */\n  getReusableChildViews: function() {\n    return this._childViews;\n  },\n\n  /**\n    @private\n    @method positionOrderedChildViews\n  */\n  positionOrderedChildViews: function() {\n    return this.getReusableChildViews().sort(sortByContentIndex);\n  },\n\n  arrayWillChange: Ember.K,\n\n  /**\n    @private\n    @event arrayDidChange\n  */\n  // TODO: refactor\n  arrayDidChange: function(content, start, removedCount, addedCount) {\n    var index, contentIndex;\n\n    if (this.state === 'inDOM') {\n      // ignore if all changes are out of the visible change\n      if( start >= this._lastStartingIndex || start < this._lastEndingIndex) {\n        index = 0;\n        // ignore all changes not in the visible range\n        // this can re-position many, rather then causing a cascade of re-renders\n        forEach.call(\n          this.positionOrderedChildViews(),\n          function(childView) {\n            contentIndex = this._lastStartingIndex + index;\n            this._reuseChildForContentIndex(childView, contentIndex);\n            index++;\n          },\n          this\n        );\n      }\n\n      syncChildViews.call(this);\n    }\n  }\n});\n\n})();\n//@ sourceURL=list-view/list_view_mixin");minispade.register('list-view', "(function() {minispade.require(\"list-view/list_item_view\");\nminispade.require(\"list-view/reusable_list_item_view\");\nminispade.require(\"list-view/list_view\");\nminispade.require(\"list-view/virtual_list_view\");\n\n})();\n//@ sourceURL=list-view");minispade.register('list-view/reusable_list_item_view', "(function() {minispade.require('list-view/list_item_view_mixin');\n\nvar get = Ember.get, set = Ember.set;\n\nEmber.ReusableListItemView = Ember.View.extend(Ember.ListItemViewMixin, {\n  init: function(){\n    this._super();\n    this.set('context', Ember.ObjectProxy.create());\n  },\n  isVisible: Ember.computed('context.content', function(){\n    return !!this.get('context.content');\n  }),\n  updateContext: function(newContext){\n    var context = get(this, 'context.content');\n    if (context !== newContext) {\n      if (this.state === 'inDOM') {\n        this.prepareForReuse(newContext);\n      }\n      set(this, 'context.content', newContext);\n    }\n  },\n  prepareForReuse: Ember.K\n});\n\n})();\n//@ sourceURL=list-view/reusable_list_item_view");minispade.register('list-view/virtual_list_scroller_events', "(function() {var fieldRegex = /input|textarea|select/i,\n  hasTouch = ('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch,\n  handleStart, handleMove, handleEnd, handleCancel,\n  startEvent, moveEvent, endEvent, cancelEvent;\nif (hasTouch) {\n  startEvent = 'touchstart';\n  handleStart = function (e) {\n    var touch = e.touches[0],\n      target = touch && touch.target;\n    // avoid e.preventDefault() on fields\n    if (target && fieldRegex.test(target.tagName)) {\n      return;\n    }\n    bindWindow(this.scrollerEventHandlers);\n    this.willBeginScroll(e.touches, e.timeStamp);\n    e.preventDefault();\n  };\n  moveEvent = 'touchmove';\n  handleMove = function (e) {\n    this.continueScroll(e.touches, e.timeStamp);\n  };\n  endEvent = 'touchend';\n  handleEnd = function (e) {\n    // if we didn't end up scrolling we need to\n    // synthesize click since we did e.preventDefault()\n    // on touchstart\n    if (!this._isScrolling) {\n      synthesizeClick(e);\n    }\n    unbindWindow(this.scrollerEventHandlers);\n    this.endScroll(e.timeStamp);\n  };\n  cancelEvent = 'touchcancel';\n  handleCancel = function (e) {\n    unbindWindow(this.scrollerEventHandlers);\n    this.endScroll(e.timeStamp);\n  };\n} else {\n  startEvent = 'mousedown';\n  handleStart = function (e) {\n    if (e.which !== 1) return;\n    var target = e.target;\n    // avoid e.preventDefault() on fields\n    if (target && fieldRegex.test(target.tagName)) {\n      return;\n    }\n    bindWindow(this.scrollerEventHandlers);\n    this.willBeginScroll([e], e.timeStamp);\n    e.preventDefault();\n  };\n  moveEvent = 'mousemove';\n  handleMove = function (e) {\n    this.continueScroll([e], e.timeStamp);\n  };\n  endEvent = 'mouseup';\n  handleEnd = function (e) {\n    unbindWindow(this.scrollerEventHandlers);\n    this.endScroll(e.timeStamp);\n  };\n  cancelEvent = 'mouseout';\n  handleCancel = function (e) {\n    if (e.relatedTarget) return;\n    unbindWindow(this.scrollerEventHandlers);\n    this.endScroll(e.timeStamp);\n  };\n}\n\nfunction handleWheel(e) {\n  this.mouseWheel(e);\n  e.preventDefault();\n}\n\nfunction bindElement(el, handlers) {\n  el.addEventListener(startEvent, handlers.start, false);\n  el.addEventListener('mousewheel', handlers.wheel, false);\n}\n\nfunction unbindElement(el, handlers) {\n  el.removeEventListener(startEvent, handlers.start, false);\n  el.removeEventListener('mousewheel', handlers.wheel, false);\n}\n\nfunction bindWindow(handlers) {\n  window.addEventListener(moveEvent, handlers.move, true);\n  window.addEventListener(endEvent, handlers.end, true);\n  window.addEventListener(cancelEvent, handlers.cancel, true);\n}\n\nfunction unbindWindow(handlers) {\n  window.removeEventListener(moveEvent, handlers.move, true);\n  window.removeEventListener(endEvent, handlers.end, true);\n  window.removeEventListener(cancelEvent, handlers.cancel, true);\n}\n\nEmber.VirtualListScrollerEvents = Ember.Mixin.create({\n  init: function() {\n    this.on('didInsertElement', this, 'bindScrollerEvents');\n    this.on('willDestroyElement', this, 'unbindScrollerEvents');\n    this.scrollerEventHandlers = {\n      start: bind(this, handleStart),\n      move: bind(this, handleMove),\n      end: bind(this, handleEnd),\n      cancel: bind(this, handleCancel),\n      wheel: bind(this, handleWheel)\n    };\n    return this._super();\n  },\n  bindScrollerEvents: function() {\n    var el = this.get('element'),\n      handlers = this.scrollerEventHandlers;\n    bindElement(el, handlers);\n  },\n  unbindScrollerEvents: function() {\n    var el = this.get('element'),\n      handlers = this.scrollerEventHandlers;\n    unbindElement(el, handlers);\n    unbindWindow(handlers);\n  }\n});\n\nfunction bind(view, handler) {\n  return function (evt) {\n    handler.call(view, evt);\n  };\n}\n\nfunction synthesizeClick(e) {\n  var point = e.changedTouches[0],\n    target = point.target,\n    ev;\n  if (target && fieldRegex.test(target.tagName)) {\n    ev = document.createEvent('MouseEvents');\n    ev.initMouseEvent('click', true, true, e.view, 1, point.screenX, point.screenY, point.clientX, point.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);\n    return target.dispatchEvent(ev);\n  }\n  return void 0;\n}\n\n})();\n//@ sourceURL=list-view/virtual_list_scroller_events");minispade.register('list-view/virtual_list_view', "(function() {/*global Scroller*/\nminispade.require('list-view/list_view_mixin');\nminispade.require('list-view/list_view_helper');\nminispade.require('list-view/virtual_list_scroller_events');\n\nvar max = Math.max, get = Ember.get, set = Ember.set;\n\nfunction updateScrollerDimensions(target) {\n  var width, height, totalHeight, totalWidth, isHoriz;\n\n  target = target || this;\n\n  isHoriz = get(target, 'isHorizontal');\n  width = get(target, 'width');\n  height = get(target, 'height');\n  totalHeight = isHoriz ? height : get(target, 'totalHeight');\n  totalWidth = isHoriz ? get(target, 'totalWidth') : width;\n\n  target.scroller.setDimensions(width, height, totalWidth, totalHeight);\n  target.trigger('scrollerDimensionsDidChange');\n}\n\n/**\n  VirtualListView\n\n  @class VirtualListView\n  @namespace Ember\n*/\nEmber.VirtualListView = Ember.ContainerView.extend(Ember.ListViewMixin, Ember.VirtualListScrollerEvents, {\n  _isScrolling: false,\n  _mouseWheel: null,\n  css: {\n    position: 'relative',\n    overflow: 'hidden'\n  },\n\n  init: function(){\n    this._super();\n    this.setupScroller();\n    this.setupPullToRefresh();\n  },\n  _scrollerOffset: 0,\n  applyTransform: Ember.ListViewHelper.apply3DTransform,\n\n  setupScroller: function(){\n    var view, isHoriz;\n\n    view = this;\n    isHoriz = this.get('isHorizontal');\n\n    view.scroller = new Scroller(function(left, top, zoom) {\n      if (view.state !== 'inDOM') { return; }\n\n      if (view.listContainerElement) {\n        if ( isHoriz ) {\n          view.applyTransform(view.listContainerElement, -left, 0);\n          view._scrollerOffset = left;\n        } else {\n          view.applyTransform(view.listContainerElement, 0, -top);\n          view._scrollerOffset = top;\n        }\n        view._scrollContentTo(view._scrollerOffset);\n      }\n    }, {\n      scrollingY: !isHoriz,\n      scrollingX: isHoriz,\n      scrollingComplete: function(){\n        view.trigger('scrollingDidComplete');\n      }\n    });\n\n    view.trigger('didInitializeScroller');\n    updateScrollerDimensions(view);\n  },\n  setupPullToRefresh: function() {\n    if (!this.pullToRefreshViewClass) { return; }\n    this._insertPullToRefreshView();\n    this._activateScrollerPullToRefresh();\n  },\n  _insertPullToRefreshView: function(){\n    this.pullToRefreshView = this.createChildView(this.pullToRefreshViewClass);\n    this.insertAt(0, this.pullToRefreshView);\n    var offset, view = this, isHoriz = view.get('isHorizontal');\n    this.pullToRefreshView.on('didInsertElement', function() {\n      offset = -1 * view.pullToRefreshViewSize;\n      view.applyTransform(this.get('element'), isHoriz ? offset : 0, isHoriz ? 0 : offset);\n    });\n  },\n  _activateScrollerPullToRefresh: function(){\n    var view = this;\n    function activatePullToRefresh(){\n      view.pullToRefreshView.set('active', true);\n      view.trigger('activatePullToRefresh');\n    }\n    function deactivatePullToRefresh() {\n      view.pullToRefreshView.set('active', false);\n      view.trigger('deactivatePullToRefresh');\n    }\n    function startPullToRefresh() {\n      view.pullToRefreshView.set('refreshing', true);\n\n      function finishRefresh(){\n        if (view && !view.get('isDestroyed') && !view.get('isDestroying')) {\n          view.scroller.finishPullToRefresh();\n          view.pullToRefreshView.set('refreshing', false);\n        }\n      }\n      view.startRefresh(finishRefresh);\n    }\n    this.scroller.activatePullToRefresh(\n      this.pullToRefreshViewSize,\n      activatePullToRefresh,\n      deactivatePullToRefresh,\n      startPullToRefresh\n    );\n  },\n\n  getReusableChildViews: function(){\n    var firstView = this._childViews[0];\n    if (firstView && firstView === this.pullToRefreshView) {\n      return this._childViews.slice(1);\n    } else {\n      return this._childViews;\n    }\n  },\n\n  scrollerDimensionsNeedToChange: Ember.observer(function() {\n    Ember.run.once(this, updateScrollerDimensions);\n  }, 'width', 'height', 'totalHeight', 'totalWidth', 'isHorizontal'),\n\n  didInsertElement: function() {\n    this.listContainerElement = this.$('> .ember-list-container')[0];\n  },\n\n  willBeginScroll: function(touches, timeStamp) {\n    this._isScrolling = false;\n    this.trigger('scrollingDidStart');\n\n    this.scroller.doTouchStart(touches, timeStamp);\n  },\n\n  continueScroll: function(touches, timeStamp) {\n    var startingScrollOffset, endingScrollOffset, event;\n\n    if (this._isScrolling) {\n      this.scroller.doTouchMove(touches, timeStamp);\n    } else {\n      startingScrollOffset = this._scrollerOffset;\n\n      this.scroller.doTouchMove(touches, timeStamp);\n\n      endingScrollOffset = this._scrollerOffset;\n\n      if (startingScrollOffset !== endingScrollOffset) {\n        event = Ember.$.Event(\"scrollerstart\");\n        Ember.$(touches[0].target).trigger(event);\n\n        this._isScrolling = true;\n      }\n    }\n  },\n\n  endScroll: function(timeStamp) {\n    this.scroller.doTouchEnd(timeStamp);\n  },\n\n  // api\n  scrollTo: function(offset, animate) {\n    var isHoriz = get(this, 'isHorizontal');\n    if (animate === undefined) {\n      animate = true;\n    }\n\n    this.scroller.scrollTo(isHoriz ? offset : 0, isHoriz ? 0 : offset, animate, 1);\n  },\n\n  // events\n  mouseWheel: function(e){\n    var inverted, delta, candidatePosition, isHoriz = get(this, 'isHorizontal');\n\n    inverted = e.webkitDirectionInvertedFromDevice;\n    delta = e[isHoriz ? 'wheelDeltaX' : 'wheelDeltaY'];\n    if ( isHoriz && !delta ) delta = e.wheelDeltaY;\n    delta = delta * (inverted ? 0.8 : -0.8);\n    candidatePosition = this.scroller[isHoriz ? '__scrollLeft' : '__scrollTop'] + delta;\n\n    if ((candidatePosition >= 0) && (candidatePosition <= this.scroller[isHoriz ? '__maxScrollLeft' : '__maxScrollTop'])) {\n      this.scroller.scrollBy(isHoriz ? delta : 0, isHoriz ? 0 : delta, true);\n    }\n\n    return false;\n  }\n});\n\n})();\n//@ sourceURL=list-view/virtual_list_view");